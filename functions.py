# Задача 1.
# Создайте функцию greet(), которая выводит на экран приветствие "Добро пожаловать!".
# Вызовите эту функцию.

def greet():
    print("Добро пожаловать!")
greet()

# Задача 2.
# Создайте функцию add_numbers(a, b), которая принимает два аргумента (числа) и возвращает их сумму.
# Вызовите функцию с аргументами 5 и 3, сохраните результат в переменную result и выведите его на экран.

def add_numbers(a, b):
    return a + b
result = add_numbers(5, 3)
print(result)

# Задача 3.
# Создайте функцию greet_user(name),
# которая принимает один аргумент name и возвращает строку в формате: "Привет, [name]!".
# Вызовите функцию с аргументом "Анна" и выведите результат на экран.

def greet_user(name):
    return f"Привет {name}!"
print(greet_user("Анна"))

# Задача 4.
# Создайте функцию power(base, exponent=2), которая принимает два аргумента:
# base (основание, обязательный аргумент)
# exponent (показатель степени, по умолчанию равен 2)
# Функция должна возвращать результат возведения base в степень exponent.
# Вызовите функцию:
# С одним аргументом power(5) (должно вернуть 25)
# С двумя аргументами power(3, 4) (должно вернуть 81)
# Выведите оба результата на экран.

def power(base, exponent=2):
    return base ** exponent
print(power(5))
print(power(3,4))

# Задача 5.
# Создайте функцию multiply_by_two(number), которая принимает число и возвращает это число, умноженное на 2.
# Затем создайте декоратор print_result, который будет выводить на экран сообщение "Результат: "
# перед возвращаемым значением функции.
# Примените этот декоратор к функции multiply_by_two. Вызовите декорированную функцию с аргументом 7.
# Подсказка: используйте простейший синтаксис декоратора без @.

def multiply_by_two(number):
    return number * 2
def print_result(func):
    def wrapper(number):
        result = func(number)
        print(f"Результат: {result} ")
        return result
    return wrapper
decorated_func = print_result(multiply_by_two)
decorated_func(7)

# Задача 6.
# Создайте функцию describe_pet(pet_name, animal_type="собака"), которая принимает два аргумента:
# pet_name (обязательный) — имя питомца
# animal_type (по умолчанию "собака") — вид животного
# Функция должна возвращать строку в формате:
# "У меня есть [animal_type] по имени [pet_name]."
# Вызовите функцию три раза:
# Только с обязательным аргументом
# С обоими аргументами (animal_type="кот")
# С обоими аргументами в другом порядке (используя именованные аргументы)
# Выведите все три результата на экран.

def describe_pet(pet_name, animal_type="собака"):
    return f"У меня есть {animal_type} по имени {pet_name}"
print(describe_pet("Муся"))
print(describe_pet("Муся", "кот"))
print(describe_pet(animal_type="кот", pet_name="Муся"))

# Задача 1 (Функции с возвратом значения и условной логикой).
# Создайте функцию is_even(number), которая принимает целое число и возвращает True,
# если число чётное, и False — если нечётное.
# Вызовите функцию с числами 4 и 7, выведите результаты.

def is_even(number):
    if number % 2 == 0:
        return True
    else:
        return False
print(is_even(4))
print(is_even(7))

# Задача 2 (Аргументы с дефолтными значениями и строковые операции).
# Создайте функцию create_email(username, domain="company.com"),
# которая принимает имя пользователя и домен (по умолчанию "company.com"),
# и возвращает строку электронной почты в формате username@domain.
# Вызовите функцию:
# С одним аргументом "ivan"
# С двумя аргументами "anna", "gmail.com"
# Выведите оба результата.

def create_email(username, domain="company.com"):
    return f"{username}@{domain}"
print(create_email("ivan"))
print(create_email("anna","gmail.com"))

# Задача 3 (Несколько аргументов, работа со списком внутри функции).
# Создайте функцию sum_numbers(*args), которая принимает произвольное количество чисел (используйте *args)
# и возвращает их сумму.
# Вызовите функцию с аргументами 1, 2, 3, 4, 5 и выведите результат.

def sum_numbers(*args):
    return sum(args)
print(sum_numbers(1,2,3,4,5))

# Задача 4 (Декоратор с практическим смыслом).
# Создайте декоратор timer, который выводит "Функция начала работу" перед вызовом функции
# и "Функция завершила работу" после её выполнения.
# Примените его к функции calculate(a, b), которая возвращает сумму двух чисел.
# Вызовите декорированную функцию с аргументами 5 и 3, выведите результат.
# Подсказка: структура декоратора как в последнем примере, но с двумя print-ами.


def calculate(a, b):
    return a + b
def timer(func):
    def wrapper(a, b):
        print("Функция начала работу")
        timer_result = func(a, b)
        print("Функция завершила работу")
        return timer_result
    return wrapper

decorated_func = timer(calculate)
result = decorated_func(5, 3)
print(result)

# Задача 5 (Декоратор с @ и полезной логикой).
# Создайте декоратор validate_positive, который проверяет, что оба аргумента функции — положительные числа.
# Если какой-то аргумент ≤ 0, декоратор выводит "Аргументы должны быть положительными!" и возвращает None.
# Иначе вызывает исходную функцию.
# Примените декоратор к функции multiply(a, b), которая возвращает произведение двух чисел,
# используя синтаксис @validate_positive.
# Вызовите декорированную функцию для случаев:
# multiply(5, 3)
# multiply(-2, 10)
# Выведите результаты.
# Подсказка: в декораторе нужна проверка if a <= 0 or b <= 0: ....

def validate_positive(func):
    def wrapper(a, b):
        if a <= 0 or b <= 0:
            print("Аргументы должны быть положительными!")
            return None
        else:
            return func(a, b)
    return wrapper

@validate_positive
def multiply(a, b):
    return a * b
print((multiply(5,3)))
print((multiply(-2,10)))
