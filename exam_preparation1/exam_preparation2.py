
# Задача 1 (Работа с файлами).
# Напишите код, который:
# Создаёт файл notes.txt в режиме записи ('w') с помощью контекстного менеджера with.
# Записывает в файл две строки:
# "Первая заметка"
# "Вторая заметка"
# Каждая строка должна быть на новой строке в файле
# Подсказка: используйте write() с символом \n.

with open("notes.txt", "w") as f:
    f.write("Первая заметка\n")
    f.write("Вторая заметка\n")

# Задача 2 (Срезы списков).
# Создайте список numbers = [10, 20, 30, 40, 50, 60, 70, 80].
# Напишите код, который с помощью срезов создаёт и выводит:
# Первые три элемента списка
# Последние три элемента списка
# Элементы с индексом от 2 до 5 (включительно)
# Каждый вывод — на отдельной строке, в виде списка.

numbers = [10, 20, 30, 40, 50, 60, 70, 80]
print(numbers[:3])
print(numbers[-3:])
print(numbers[2:6])

# Задача 3 (Функции: аргументы с дефолтными значениями).
# Создайте функцию greet_user(name, greeting="Привет"), которая принимает два аргумента:
# name (обязательный) — имя пользователя
# greeting (необязательный, по умолчанию "Привет") — приветствие
# Функция должна возвращать строку в формате: "[greeting], [name]!".
# Вызовите функцию три раза и выведите результаты:
# С двумя аргументами: "Доброе утро", "Анна"
# Только с обязательным аргументом: "Петр"
# С именованными аргументами в другом порядке: name="Мария", greeting="Здравствуй"

def greet_user(name, greeting = "Привет"):
    return f"{greeting}, {name}!"
print(greet_user("Анна", "Доброе утро"))
print(greet_user("Петр"))
print(greet_user(name="Мария", greeting="Здравствуй"))

# Задача 4 (Словари: проверка наличия ключей и значений).
# Создайте словарь student = {"name": "Алексей", "age": 21, "course": 3}.
# Напишите код, который проверяет:
# Есть ли в словаре ключ "age" (вывести "Ключ 'age' есть" или "Ключа 'age' нет")
# Есть ли в словаре значение "Алексей" (вывести "Значение 'Алексей' есть" или "Значения 'Алексей' нет")
# Есть ли в словаре ключ "grade" (вывести "Ключ 'grade' есть" или "Ключа 'grade' нет")
# Используйте оператор in для проверки ключей и метод для проверки значений.

student = {
    "name": "Алексей",
    "age": 21,
    "course": 3}

if "age" in student:
    print("Ключ 'age' есть")
else:
    print("Ключа 'age' нет")

if "Алексей" in student.values():
    print("Значение 'Алексей' есть")
else:
    print("Значения 'Алексей' нет")

if "grade" in student:
    print("Ключ 'grade' есть")
else:
    print("Ключа 'grade' нет")

# Задача 5 (Цикл for с range).
# Напишите код, который с помощью цикла for и функции range() выводит все чётные числа от 2 до 20 включительно.
# Каждое число должно выводиться на отдельной строке.
# Подсказка: используйте range() с тремя аргументами (start, stop, step).

for number in range(2,21,2):
    print(number)

# Задача 6 (ООП: создание класса, конструктор, методы).
# Создайте класс Rectangle (Прямоугольник) с конструктором __init__, который принимает два параметра:
# length (длина)
# width (ширина)
# Сохраните их в атрибуты self.length и self.width.
# Добавьте два метода:
# area() — возвращает площадь прямоугольника
# is_square() — возвращает True, если прямоугольник является квадратом (длина равна ширине), иначе False.
# Создайте объект rect = Rectangle(5, 5).
# Вызовите оба метода и выведите результаты (площадь и является ли квадратом).

class Rectangle:

    def __init__(self, length, width):
        self.length = length
        self.width = width

    def area(self):
        return self.length * self.width

    def is_square(self):
        return True if self.length == self.width else False

rect = Rectangle(5,5)

print(rect.area())
print(rect.is_square())

# Задача 7 (Конкатенация строк и f-строки).
# Создайте три переменные:
# city = "Москва"
# country = "Россия"
# population = 12_000_000 (число)
# Напишите код, который:
# С помощью конкатенации строк (оператор +) создаёт строку "Город: Москва, Страна: Россия" и выводит её
# С помощью f-строки создаёт строку "Население Москвы: 12_000_000 человек" (число вывести без подчёркиваний)
# и выводит её
# Подсказка: в f-строке число population будет выведено как 12000000.

city = "Москва"
country = "Россия"
population = 12_000_000

print("Город: " + city + ", Страна: " + country)
print(f"Население Москвы: {population} человек")

# Задача 8 (Логические операции в условиях).
# Напишите код, который проверяет переменные:
# age = 25
# has_license = True
# Условия:
# Если возраст больше или равен 18 И есть водительские права (has_license равно True),
# вывести "Можно водить машину"
# Иначе вывести "Нельзя водить машину"
# Используйте логическую операцию and в условии if.

age = 25
has_license = True

if age >= 18 and has_license:
    print("Можно водить машину")
else:
    print("Нельзя водить машину")

# Задача 9 (Добавление/замена элементов в списке).
# Создайте список colors = ["red", "blue", "green"].
# Напишите код, который:
# Добавляет строку "yellow" в конец списка.
# Заменяет второй элемент (индекс 1) на строку "purple"
# Вставляет строку "orange" на позицию с индексом 0 (начало списка)
# Выводит итоговый список
# Используйте методы .append(), обращение по индексу и .insert().

colors = ["red", "blue", "green"]

colors.append("yellow")
colors[1] = "purple"
colors.insert(0, "orange")
print(colors)

# Задача 10 (Наследование с расширением функциональности).
# Создайте родительский класс Device с конструктором __init__,
# принимающим параметр name (название устройства). Сохраните его в self.name.
# Добавьте метод turn_on, который возвращает строку "[name] включён(а)".
# Создайте дочерний класс SmartDevice, который наследует от Device.
# В классе SmartDevice:
# Добавьте конструктор __init__, принимающий два параметра:
# name и battery_level (уровень заряда в процентах, целое число).
# Используйте super().__init__(name) для инициализации родительского атрибута.
# Сохраните battery_level в self.battery_level.
# Переопределите метод turn_on, чтобы он возвращал строку: "[name] включён(а).
# Уровень заряда: [battery_level]%".
# Добавьте новый метод charge, который увеличивает battery_level на 20 (но не более 100).
# Создайте объект smart = SmartDevice("Смартфон", 30).
# Вызовите turn_on, затем charge, затем снова turn_on. Выведите оба результата turn_on на экран.

class Device:

    def __init__(self, name):
        self.name = name

    def turn_on(self):
        return f"{self.name} включен(а)"

class SmartDevice(Device):

    def __init__(self, name, battery_level):
        super().__init__(name)
        self.battery_level = battery_level

    def turn_on(self):
        return f"{self.name} включен(а). Уровень заряда: {self.battery_level}"

    def charge(self):
        self.battery_level = self.battery_level + 20
        if self.battery_level > 100:
            self.battery_level = 100

smart = SmartDevice("Смартфон", 30)
print(smart.turn_on())
smart.charge()
print(smart.turn_on())

# Задача 11 (Операции сравнения).
# Создайте две переменные:
# x = 15
# y = 20
# Напишите код, который выводит результаты всех шести операций сравнения между x и y (>, <, ==, !=, >=, <=).
# Каждый результат выводите на отдельной строке в формате:
# x > y: False
# x < y: True

x = 15
y = 20
print(f"x > y: {x > y}")
print(f"x<y: {x < y}")
print(f"x==y: {x == y}")
print(f"x!=y: {x != y}")
print(f"x>=y: {x >= y}")
print(f"x<=y: {x <= y}")

# Задача 12 (Слияние списков).
# Создайте два списка:
# list1 = [1, 2, 3]
# list2 = [4, 5, 6]
# Напишите код, который:
# Создаёт новый список merged путём слияния list1 и list2 (все элементы в одном списке)
# Выводит merged.
# Используйте оператор + для слияния списков.

list1 = [1, 2, 3]
list2 = [4, 5, 6]

merged = list1 + list2
print(merged)

# Задача 13 (Декоратор).
# Создайте декоратор repeat_twice, который вызывает декорированную функцию два раза подряд.
# Примените этот декоратор к функции say_hello, которая выводит "Привет!".
# Вызовите декорированную функцию. Ожидается вывод двух строк "Привет!".
# Подсказка: структура декоратора как в предыдущих примерах, но с двумя вызовами func() внутри wrapper.

def say_hello():
    print("Привет!")
def repeat_twice(func):
    def wrapper(*args, **kwargs):
        func(*args, **kwargs)
        func(*args, **kwargs)
    return wrapper

decorated_func = repeat_twice(say_hello)
decorated_func()

# Задача 14 (Простой декоратор с пояснениями).
# Создайте декоратор my_decorator, который делает следующее:
# Перед вызовом функции выводит "Начало".
# Вызывает саму функцию.
# После вызова функции выводит "Конец".
# Примените этот декоратор к функции example, которая выводит "Пример".

def example():
    print("Пример")
def my_decorator(func):
    def wrapper():
        print("Начало")
        func()
        print("Конец")
    return wrapper

decorated = my_decorator(example)
decorated()

# Задача 15 (Декоратор с аргументами и возвращаемым значением).
# Создайте декоратор add_prefix, который:
# Принимает один аргумент — prefix (строка).
# Возвращает декоратор, который оборачивает функцию.
# Декорированная функция должна возвращать строку в формате: "[prefix] [результат функции]"
# Примените декоратор с префиксом "Результат:" к функции get_message, которая возвращает строку "Hello World".
# Вызовите декорированную функцию и выведите результат.

def add_prefix(prefix):
    def decorator(func):
        def wrapper(*args, **kwargs):
            result = func(*args, **kwargs)
            return f"{prefix} {result}"
        return wrapper
    return decorator

def get_message():
    return "Hello World!"

decorated_func = add_prefix("Результат:")(get_message)
print(decorated_func())
